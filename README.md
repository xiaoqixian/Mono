#### **Mono Filesystem**

![](pics/Mono.png)
---
![](pics/grass.jpg)

[Here](README-ENG_VER.md) is the English version of README.md if you need.

原项目地址：https://github.com/elliotxx/os_filesystem

前排提示：由于作者懒惰，vim命令尚未实现。同时文档也并未将所有函数都仔细讲解，但是文件系统最精髓之处已经讲到。

**载入过程**

1. 首先是磁盘位置的确定。

   超级块占据着虚拟磁盘的第一块磁盘块。

   接下来是iNode bitmap和blcok bitmap，分别占据了两个磁盘块和20个磁盘块，一个磁盘块是512Byte，所以分别可以监视1024个iNode和10240个block。这里要注意的是虽然一个磁盘是512byte但是只能监视512个iNode或block，因为这里用在虚拟文件中只能用一个字节以上的大小存储数据，无法做到真正的一个bit。

   然后是iNode区和block区。

2. 间接块

   当要存储大文件时，可能iNode中准备的存储block编号的数组不够了，这时就需要间接块的出场了。在iNode结构体中，有一个名为i_indirBlock_1的整形变量，这个变量存储的是间接块的编号，在它指向的间接快中则存储了文件的磁盘块的编号。由于一个block有512B的大小，所以可以存储更多的block编号。

   其实在一级间接块下面还可以有更多的间接块以支持更大的文件存储，但是本系统暂时只支持1级间接块。

**格式化過程**

文件系统在第一次进行安装以及在用户需要的时候会进行格式化。

1. 超级块的格式化

   超级块的格式化主要是创建一个超级块结构体并进行赋值。

2. iNode位图和block位图的格式化

3. 数据区域的格式化

   数据区域采用组链接法来组织所有的block，每一组有64个block。在每一组的数组的0号位置标记的是下一组的组头的起始地址。第一组的起始地址不用标记，因为就是block 区域的起始地址，最后一组的0号没有位置需要标记。
   
   在格式化过程中，利用超级块的s_free栈作为暂时存储的地方，首先在0号位置放入下一组开始的地址。然后在其他每一格中都放入该block的地址。最后将这个s_free数组写入到该组block的起始block中。没错，组block的地址数据就是放在该组最前面的那个block中。但是不用担心这个数据被覆盖，因为在前面的一组block的最后一个block使用时，会先将这组block的地址数据读取到超级块的s_free中，然后这组block就可以随意写入了。

**block分配函数`balloc()`**

`balloc()`函数用于给目录和文件的存储分配block，返回被分配block的地址。

由于磁盘块采用的组织方式是组链接方式，所以要先访问超级块，看超级块的s_free_addr属性是否为0，如果是的话就说明已经没有磁盘块(在分配完最后一个磁盘块后就会将此属性置零)。然后利用取余的方式取得最前的一个空闲磁盘块位于空闲磁盘块栈的哪一格。

如果空闲磁盘块指向栈底，说明本空闲磁盘块栈用完了，需要将一个新的磁盘块组读取到空闲磁盘块组中。首先函数需要返回的值还是本组block的栈底的一个，但是栈底的block的地址并不是放在s_free[0]中，而是在超级块的s_free_addr中。这个属性是在超级块读取一组新的block group时赋的，一直未被使用，就是在更换group时使用。

所以要取的新的block的地址，如果不是栈底的block，就直接返回s_free中的地址，否则返回s_free_addr中的地址。

**iNode分配函数`ialloc()`**

`ialloc()`用于分配iNode，返回iNode的地址。

相比`balloc()`，`ialloc()`的步骤简单很多，就是线性地查找空闲的iNode，找到后就将相应的位置写为1，表示非空闲，更新超级块，返回地址。

**block释放函数`bfree()`**

相比于block的分配，block的释放显得更加困难。因为分配可以是线性的，而释放是在所有的block区域都可能发生的，所以如何将释放后的block串接到可分配的block中是个问题。

本项目采用的算法是：根据要释放block的地址计算block的块号。(中间对于地址合理性判断的部分省去不表)。然后，先将相应的block内容擦去，如果是利用一块写满0的数组擦除的话，用完记得将数组的内存释放，原作者的代码就没有释放这段内存，要养成勤于释放内存的好习惯。再判断当前的空闲block栈是否已满。如果是，则就新创建一个block group，并且优先使用这个block group。要达到这一步，就先将存放本来的下一个空闲block组首地址的s_free[0]改为s_free_addr，前面讲过，这个地址是用来存放当前block栈的栈底的block的地址的。再将栈里面其它位置的地址都置-1，就实现了当前block组从超级块的s_free空闲栈中移出的操作。最后再将移出来的这组block的数据写入到要释放的block中。

但是按道理来说，原作者是想本block再作为最新的空闲block栈的栈底，这样的话s_free_addr应该指向要释放的block的地址，但是我在原作者的代码并没有看到这一行代码，所以我斗胆加上了这样一行代码。如果是在栈满的情况下，按道理说空闲block的数量应该是block group size的整数倍，所以这个要释放的block就是唯一多出来的那个，于是按照block allocate的算法，在使用完这个block之后就会直接跳转到原来的那组block。于是要释放的block就会优先使用了。

如果栈未满的话就比较简单了，直接在栈中加一格，地址指向要释放的block。

**創建目录函数`mkdir()`**

首先讲一下Linux文件系统创建目录的过程，Linux创建目录时至少分配一个iNode和一个block，iNode用来记录目录的相关权限与属性，block用来记录文件名和目录iNode的地址。

对于mkdir函数的参数，需要传入parinoAddr，即父目录的iNode地址以及需要创建的文件名。但是这个父目录并不是当前目录的父目录，而是对于创建的目录来说的父目录，也就是当前目录。

首先将当前地址的iNode读取出来，然后每隔16个目录项的去找iNode的dirlist属性，为什么是16呢？因为前面讲到block中主要用来记载目录的目录名和iNode地址，而地址类型是int，也就是4个字节。再加上名字的最长允许长度是28字节，所以总共是32字节(**这两者合在一起也称为一个目录项**)。而一个block的大小是512字节，所以一个block可以存放16个目录项。在不使用间接块的情况下，目录iNode的dirlist可以存放10个block地址，也就是一个目录下可以创造160个目录。

接下来为了找到一个合适的地方放下需要创建的目录项，就需要遍历这全部的160个目录项，需要遍历全部的目录项的原因是防止出现重名的目录，原作者只禁止两个同目录下目录重名，但是Linux中同目录下文件和目录都不准重名，所以这里我按照Linux的标准改写。

先遍历10个直接块找到可以存放目录项的那个block，找到后读出来放入dirlist，然后遍历dirlist，如果有重名的，则创建失败，如果遇到空白位置(方法就是检测目录项的名字是否等于""，只有空目录才没有名字)，找到后记下block和在block的位置，然后需要继续遍历，为的是防止接下来的block中有重名的目录。

找到合适的block后就可以创建目录了。首先读取选中block的dirlist，然后利用ialloc()函数创建一个iNode，写入相关信息，如i_inode表示iNode标识符，唯一识别一个iNode，这里就是简单的取值为第几个iNode。写入信息后分配一个block用来存储创建目录的dirlist。目录创建之初就已经在里面创建了两个名为"."和".."的目录分别指向本目录和父目录。最后将block写入，iNode的i_dirBlock的0位指向最初的这个block，其它的全部置-1。然后iNode也写入。最后当前目录修改一些东西也写入。

在这里需要讲一下的原作者的mkdir函数的一个bug，他没有考虑当一个block满了之后的情况，就只是考虑了尽量将目录项放到已经有目录的block中，我理解是为了尽量一个目录项尽量使用少的block，因为一个目录虽然可以存放十个block，但是不是一开始就创建了10个block，而是有需求才创建。但是原作者没有加上如果一个block满了后开创新的block的代码，导致一个目录下创建了超过15个目录后就会出现创建目录失败的提示。

所以我在他的基础上修改了一部分代码，前面部分保持不变，当没有找到合适的dirlist时，就允许自动创建一个block用来存放新的目录项。

**删除目录下所有文件与目录函数`rmall()`**

`rmall()`函数删除目录下的一切东西，但是与rm -rf ./* 命令不同的是前者会保留当前目录，`rmall()`则会连当前目录的iNode和block都会一起删除。

`rmall()`函数的实现是通过递归来实现的，首先判断当前目录下是否没有任何东西，只有两个连接("."和"..")就说明没有任何文件和目录，则直接释放iNode和block。

否则则遍历`i_dirBlock`下的所有的block，每个block遍历所有的目录项，对于每个目录项中的iNode地址，则使用递归的方式再作为输入调用本函数。这样就会直到遇到一个没有没有任何东西的目录，然后按照第一种情况处理。这一切都处理完后，就释放当前目录的iNode和blocks。

**非首次读取文件问题**

由于C语言的文件指针在以写的方式读取文件时会将文件的已有内容清零，使得文件系统在前一次登陆后的信息无法保存。

原作者的解决办法是准备一个非常大的buffer，然后先用读指针将文件读入buffer中，再去初始化写指针，这样文件中的内容即使清零也无所谓。再用写指针将buffer中的内容全部写入。

但这样做太浪费内存，而且原作者是将buffer定义为全局变量，而且是位于栈内存中，无法手动释放。我第一次试着在函数中定义一个这么大的buffer时，栈直接爆掉了。

所以我的解决办法是建立一个临时文件，先用读指针将虚拟磁盘文件的内容读入一个比较小的buffer（我设为1024byte），然后再用写指针写入临时文件。如果可以的话其实将该文件设为二号磁盘文件也没有问题，接下来就直接利用这个二号磁盘文件进行操作。但是我不喜欢两个磁盘文件，所以写了一个再将临时文件中内容写回的操作。在磁盘文件小的时候当然没问题，但很大的话就会非常低效了。

最后在读写完文件后记得将buffer内存释放，我特意将buffer的内存定义在堆中，可以在用完后立刻释放。

**编辑器**

原作者是在Windows平台上写的，所以直接调用了Windows的一些接口写了一个简单的类vim文本编辑器，虽然在按下ESC的时候会有卡住。

但是我是在Linux平台上写的，所以无法直接借鉴这段代码，所以我决定通过system函数执行shell命令调用终端的vim编辑器。然后通过vim将内容写入一个临时文件，再将临时文件中的内容读取到文件系统中。

编辑器不支持目录文件的读写。

